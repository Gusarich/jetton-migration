#include "imports/stdlib.fc";
#include "opcodes.fc";

const int ton_for_fee = 100000000;
global slice old_jetton_wallet;
global slice migration_master;
global slice recipient;

() transfer(int amount, int query_id) impure {
    send_raw_message(begin_cell()
        .store_uint(0x18, 6)
        .store_slice(old_jetton_wallet)
        .store_coins(ton_for_fee)
        .store_uint(1, 1 + 4 + 4 + 64 + 32 + 1 + 1)
        .store_ref(begin_cell()
            .store_uint(op::transfer, 32)
            .store_uint(query_id, 64)
            .store_coins(amount)
            .store_slice(migration_master)
            .store_slice(my_address())
            .store_uint(0, 6)
        .end_cell())
    .end_cell(), 1);
}

() load_data() impure inline {
    slice ds = get_data().begin_parse();
    old_jetton_wallet = ds~load_msg_addr();
    migration_master = ds~load_msg_addr();
    recipient = ds~load_msg_addr();
}

() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {
    load_data();
    slice cs = in_msg_full.begin_parse();

    int flags = cs~load_uint(4);
    slice sender = cs~load_msg_addr();
    if (flags & 1) {
        return (); ;; ignore bounced messages
    }

    int op = in_msg_body~load_uint(32);

    if (op == op::migrate) {
        if (~ equal_slices(sender, recipient)) {
            return (); ;; ignore messages not from recipient
        }
    }
    elseif (op == op::transfer_notification) {
        if (~ equal_slices(sender, old_jetton_wallet)) {
            return (); ;; ignore messages not from old_jetton_wallet
        }
    }
    else {
        return (); ;; ignore other opcodes
    }

    int query_id = in_msg_body~load_uint(64);
    int amount = in_msg_body~load_coins();

    transfer(amount, query_id);
}
